icon: edit
date: 2022-04-04
category:
  - CategoryA
  - CategoryB
tag:
  - tag A
  - tag B



# ES6

 **var ——ES5 变量声明方式** 

1. 在变量未赋值时，变量undefined（为使用声明变量时也为undefined）
2.  作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都 可以使用 

**let——ES6变量声明方式** 

1. 在变量为声明前直接使用会报错 
2. 作用域——let为块作用域——通常let比var 范围要小 
3.  let禁止重复声明变量，否则会报错；var可以重复声明 

**const——ES6变量声明方式** 

1. const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值
2. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动

**js数据类型，区别** 

**参考答案：** **基本数据类型： Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）** 

**引用数据类型：**

* object，function（proto Function.prototype）  

* object：普通对象，数组对象，正则对象，日期对象，Math数学函数对象。 

**两种数据存储方式：** 基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈 是存储基本类型值和执行代码的空间。 

引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指 针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获 得实体。 

**两种数据类型的区别：** 

1. 堆比栈空间大，栈比堆运行速度快。

2. 堆内存是无序存储，可以根据引用直接获取。 

3. 基础数据类型比较稳定，而且相对来说占用的内存小。

4. 引用数据类型大小是动态的，而且是无限的。

   

 **Object.assign的理解**

作用：Object.assign可以实现对象的合并。 

语法： Object.assign(target, ...sources) 

**解析：** 

1. Object.assign会将source里面的可枚举属性复制到target，如果和target的已有属性重名，则会覆 盖。 
2. 后续的source会覆盖前面的source的同名属性。 
3. Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会 存在引用共享的问题。

##### node事件循环

**执行栈和执行队列**

1. 所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)
2.   在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继 续执行后续的任务 
3.  一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态， 就会从任务队列进入执行栈，恢复执行 
4.  主线程不断重复上面的第三步

#### this

call apply bind都可以 改变函数内部的this指向

call 和 apply区别就是第二个参数 apply需要的是数组，call 是可以多个属性

call 和apply 使用 func.apply(thisArg,[argArray])

本质就是调用这个func给thisArg的 执行一下参数调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的this指向。

bind()方法不会调用函数，但是能改变函数内部this指向

#### 箭头函数的this

1. 箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的；
2. 箭头函数中的this指向父级作用域的执行上下文；（技巧：因为javascript中除了全局作用 域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最 近的function，与该function平级的执行上下文中的this即是箭头函数中的this）
3. 箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被 确定下来。

#### 继承

**优缺点** 

**继承的好处** 

a：提高了代码的复用性 

b：提高了代码的维护性 

c：让类与类之间产生了关系，是多态的前提 

**继承的弊端** 类的耦合性增强了,但是开发的原则：高内聚，低耦

1. **原型链继承** 

   实现方式：将子类的原型链指向父类的对象实例

原理：子类实例child的 __proto__ 指向Child的原型链prototype，而Child.prototype指向Parent 类的对象实例，该父类对象实例的 __proto__ 指向Parent.prototype,所以Child可继承Parent的构 造函数属性、方法和原型链属性、方法 优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性 缺点：无法向父类构造函数传参；且所有实例共享父类实例的属性，若父类共有属性为引用类型， 一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；实例如下：

2. **构造函数继承** 

   实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数

原理：使用call或者apply更改子类函数的作用域，使this执行父类构造函数，子类因此可以继承父 类共有属性 优点：可解决原型链继承的缺点 缺点：不可继承父类的原型链方法，构造函数不可复用

3. **组合继承** 

   原理：综合使用构造函数继承和原型链继承

优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的 缺点：会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造 函数

4. **原型式继承** 

   原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变 成了个可以随意增添属性的实例或对象，结果是将子对象的 __proto__ 指向父对象

缺点：共享引用类型 

5. **寄生式继承** 

   原理：二次封装原型式继承，并拓展

优点：可添加新的属性和方法

6. **寄生组合式继承**

原理：改进组合继承，利用寄生式继承的思想继承原型

#### new会发生什么

1. 创建空对象； var obj = {}; 
2. 设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的 prototype对象； obj.proto = ClassA.prototype; 扩展了新对象的原型链。
3. 使用新对象调用函数，函数中的this被指向新实例对象： ClassA.call(obj); //{}.构造函数(); 
4. 返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。

**构造函数的new都做了些什么？**简单来说，分为四步： 

① JS内部首先会先生成一 个对象； 

② 再把函数中的this指向该对象；

 ③ 然后执行构造函数中的语句； 

④ 最终返回该对象 实例。

#### link 和 @import 的区别 

1. 引入的内容不同 link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件 
2. 加载顺序不同 link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载 
3. 兼容性不同 link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持 
4. 对 JS 的支持不同 link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支

**src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。**

当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图 片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是 头部

**href** href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当 前文档（链接）之间的链接 在文档中添加 link 标签，浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当 前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式

#### 箭头函数部分知识点

1.箭头函数不会创建自己的this

 2.箭头函数继承而来的this指向永远不变(一创建就继承，并无法修改)

3.call()/.apply()/.bind()无法改变箭头函数中this的指向

4.箭头函数不能作为构造函数使用

5.箭头函数没有自己的arguments

**可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表！！**

6.箭头函数没有原型prototype

7.箭头函数不能用作Generator函数，不能使用yeild关键字



### 扩展运算符

#### Object 和 Symbol

 (1) Object对象 支持简写：同名属性K-V可以省略一个、函数声明可以省略function；支持属性名表达式、函 数名表达 式。（注意：以上2个——表达式和简写不能同时使用）。 对象的方法的name属性返回方法名，但有几个例外情况要小心。

新增了Object方法 Object.is()——用于解决==和===的部分兼容问题 Object.assign()——将src的所有可枚举对象属性复制到dest对象上（浅复制） Object.setPrototypeOf()、Object.getPrototypeOf() (Object.__proto属性) Object.entries()、Object.keys()、Object.values() 

ES6中5种遍历对象属性的方法 for-in——自身和继承的可枚举属性（除Symbol） Object.keys()——自身非继承的可枚举属性（除Symbol） Object.getOwnPropertyNames()——自身所有属性键名（包括不可枚举、除Symbol） Object.getOwnPropertySymbols()——自身的所有 Symbol 属性的键名 Reflect.ownKeys()——自身的所有键名



#### 元编程相关Proxy和Reflect 

1. Proxy 对目标对象加一层“拦截”（“代理”），外界对对象的访问、修改都必须先通过这层拦截层。因 而它提供了 一个机制可以对外界的访问进行过滤和改写。 用法：var proxy = new Proxy(p1,p2); p1是要被代理的目标对象，p2是配置对象。 值得注意的是：Proxy不是对目标对象透明的代理——即使不做任何拦截的情况下无法保证代 理对象与目 标对象行为的完全一致。（主要原因在于代理时，目标对象内部的this会指向代理对 象） 

2. Reflect 与Proxy一样是ES6为语言层面的用于操作对象提供的新API，目前它所拥有的对象方法与Proxy 对象一一对 应，引入目的：1.将Object对象上一些属于语言内部的方法放在Reflect上（目前都可 以放）2.修改Object对 象上某些方法的返回值，使得更加合理化（健壮）3.让Object对象的操作 从命令式完全转化为函数式

#### 编译时加载VS运行时加载——对象VS代码 

1. 模块命令：export和import；一个文件即为一个模块，除非导入否则外部无法读取模块属性； export支持：变量、函数和类 

2. export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就 会报错，下一节的 import 命令也是如此。 

3. 输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改 写接口。由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果 的语法结构。 

4. 使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户 肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。为了给用户提供方便，让 他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。 模块之间也可以继承。

#### js对象总览![js对象总览](/home/panjiancong/图片/截图/js对象总览.png)

### js工作原理

#### js单线程：

这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程， 如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不 知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变

**什么是进程？** 进程：是cpu分配资源的最小单位；（是能拥有资源和独立运行的最小单位） 

**什么是线程？** 线程：是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有 多个线程） 

**浏览器是多进程的？**

放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引 擎线程，http请求线程等。 所以，浏览器是一个多进程的。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但 是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

### 宏微队列及执行顺序

JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队 

* 宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调 

* 微列队：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调 

  

JS 执行时会区别这 2 个队列 

* JS 引擎首先必须先执行所有的初始化同步任务代码 
* 每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行，也就是优先级比宏 任务高，且与微任务所处的代码位置无关