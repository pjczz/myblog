icon: edit
date: 2022-04-01
category:
  - CategoryA
  - CategoryB
tag:
  - tag A
  - tag B
icon: edit
date: 2022-04-04
category:
  - CategoryA
  - CategoryB
tag:
  - tag A
  - tag B

# 从访问一个网址需要经历哪些步骤

### 1.DNS

DNS是记录服务器真实IP地址和对应的域名的管理服务，通过DNS服务器将 **协议 域名 目录及其文件** 中的域名转化为IP地址，得到对应的IP地址以后，将IP地址传给 应用层中的socket socket调用系统中的TCP协议(http3使用UDP协议)

DNS服务器一般使用UDP协议







### 2.TCP/IP

TCP是面向链接 可靠的 字节流的传输层通信协议

TCP链接需要三次握手 结束需要四次挥手



![TCP1](/home/panjiancong/图片/截图/TCP1.png)

这里需要注意：

**主动关闭连接的，才有 TIME_WAIT 状态。**

> 

![TCP2](/home/panjiancong/图片/截图/TCP2.png)

#### 重传

**超时重传：**

`RTT` 就是**数据从网络一端传送到另一端所需的时间**，也就是包的往返时间。ROT应略大于RTT

**快速重传：**

当某个包丢失，ACK的值在接受到该包之前都会返回ACK值为对应该包的值。发送方连续收到三个重复ACK时，就会触发重发机制。

在sack接收缓冲区信息 寻找丢失的数据，并进行重发

d-sack**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**



窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

简单说，需要一个无脑发的数量来确保TCP的传输效率，这个数量就是窗口，当接收到有包丢失，这个时候就可以确保这个丢失包之前都接受到了。

**流量控制：**

通过对窗口大小的负反馈调节实现流量控制

**TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间在减少缓存，这样就可以避免了丢包情况。**

当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了就可能造成死锁。

TCP通过为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。**

如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

***拥塞控制：***

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

**拥塞窗口 cwnd**是发送方维护的一个 的状态变量，它会根据**网络的拥塞程度动态变化的**。

- 只要网络中没有出现拥塞，`cwnd` 就会增大；

- 但网络中出现了拥塞，`cwnd` 就减少；

  

拥塞控制主要是四个算法：

- **慢启动** 指数型增加拥塞窗口 门限 到了就线性增加（拥塞避免）

- **拥塞避免** 门限 到了就线性增加

- **拥塞发生**： 

  **超时重传： 变成慢回复 窗口初始值为1 窗口门限变成堵塞前的一半**

  **快速重传： 变成快恢复 窗口变成堵塞前的一半 进入快速恢复**

- **快速恢复：发生快速重传 后 窗口变成堵塞前的一半后再+3 开始线性变化**

### 3.HTTP/HTTPS

### 4.浏览器处理

- 向浏览器输入网址
- 浏览器根据 DNS 服务器得到域名的 IP 地址
- 向这个 IP 的机器发送 HTTP 请求
- 服务器收到、处理并返回 HTTP 请求
- 浏览器接收到服务器返回的内容

![HTML解析](/home/panjiancong/图片/截图/HTML解析.jpg)

从上面这个图上，我们可以看到，浏览器渲染过程如下：

解析HTML，生成**DOM树**，解析CSS，生成**CSSOM树**

将DOM树和CSSOM树结合，生成**渲染树(Render Tree)**

**Layout(回流)**:根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）

**Painting(重绘)**:根据渲染树以及回流得到的几何信息，得到节点的绝对像素

**Display:** 将像素发送给GPU，最后通过调用操作系统Native GUI的API绘制，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会再写一篇博客来介绍）

------



#### 渲染过程

**字节流转为字符流 将HTML的字符串转为Token并表识出起始标签和结束标签**

 **生成节点对象并构建DOM**

事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。**注意：带有结束标签标识的Token不会创建节点对象**。

------



#### 构建CSSOM

DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。

构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。

**注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。**

------



#### 构建render树

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

<img src="https://pic4.zhimg.com/v2-11cb6cb025483589bde81ea76572eeb3_r.jpg">

在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

**注意：渲染树只包含可见的节点**

我们或许有个疑惑：**浏览器如果渲染过程中遇到JS文件怎么处理？**

渲染过程中，如果遇到`<script>`就停止渲染，执行 JS 代码。因为浏览器有**GUI渲染线程**与**JS引擎线程**，为了防止渲染出现不可预期的结果，这**两个线程是互斥的关系**。JavaScript的加载、解析与执行会`阻塞DOM的构建`，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 `defer(延迟)` 或者 `async(异步)` 属性（下文会介绍这两者的区别）。

**JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。**

原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。

**这是什么情况呢？**

这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。**也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。**

#### 布局与绘制

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做**回流**）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

布局流程的输出是一个“**盒模型**”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。

布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

#### 回流

前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。

#### 重绘

最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做**重绘节点**。

既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。

**比如以下情况发生回流：**

根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。

- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 元素字体大小变化
- 激活CSS伪类（例如：:hover）

一些常用且会导致回流的属性和方法：

```js
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
scrollIntoView()、scrollIntoViewIfNeeded()
getComputedStyle()
getBoundingClientRect()
scrollTo()
```

**以下情况发生重绘而不回流**

**当页面中元素样式的改变并不影响它在文档流中的位置时**（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程重绘而不回流。

**注意：回流一定会触发重绘，而重绘不一定会回流**

